<!doctype html>
<html>
<head>
	<title>Kevin James</title>
	<link rel='stylesheet' href='style.css' />
	<link rel='icon' href='favicon.png' />
</head>

<body>
	<nav>
		<div id='navCurr'>
			<a href='index.html'>KevinJames:~/</a>
			<a href='etc.html'>etc/</a>
			<a href='wargames.html'>wargames.hackme</a>
		</div>
		<ul id='navSub'>

		</ul>
		<a href='media/cv.pdf' target='_blank'>
			<div id='cv'>CV</div>
		</a>
	</nav>

	<content>
		<div id='wordFrame' class='scrolling'>
			<div id='whiteBoxTop'></div>
			<div id='whiteBoxBottom'></div>
			<div class='content'>
				<h1>Wargames</h1>
				<p>How do you define wargames? Well, basically, wargames are a hacker's wet dream. A wargame is one or more system of some kind set up somewhere in some way (and yes, the vagueness is part of what makes wargames so interesting!) with one or more hackers working to gain / maintain control of as many / a system as quickly / for as long as possible. There are innumerable possible setups, and each of them are a hell of a lot of fun.</p>

				<h2><a href='http://smashthestack.org/wargames' target='_blank'>SmashTheStack</a></h2>
				<p>SmashTheStack hosts about half a dozen wargames, not all of which I've taken a look at. Out of the ones I've so far played with, IO seems to be the easiest, and so I'll begin this page with a walkthrough of that.</p>
				<p>Now would be a good time to mention that there will be spoilers, as any tutorial dealing with a single-player wargame such as this would have to leave out the entire tutorial part to avoid the spoilers... which obviously defeats the purpose.</p>

				<h2><a href='http://io.smashthestack.org:84/' target='_blank'>IO.SmashTheStack</a></h3>
				<p>We begin the game by connecting with</p>
				<p><code>ssh level1@io.smashthestack.org</code></p>
				<p>The first password is <code>level1</code>. Welcome to the game. While you're here, and if this is your first time, you should <i>really</i> read the README... and as they say, "if you read #users as 'hashtag users' instead of 'number of users', IO is probably not for you."</p>

				<h3>level1</h4>
				<p>level1 is an introduction to how the game works. Take your time, look around a bit. The main purpose here is to learn the process for using IO. When you want to start working on the challenge, run <code>/levels/level01</code>. You see, each level has an executable in this directory which will in some way be central to how you beat the level. In some times there will be alternate executables, and sometimes those files will come with source or libraries.</p>
				<p>This level can be cracked pretty easily. I used <code>cat</code>, which works, despite being utterly inelegant. However, the... "proper"... solution would be to use <code>gdb</code> so you can prepare yourself for the following levels -- which I guarantee cannot be solved as easily.</p>
				<p>Before we get to that, though, there is another super quick and easy way of getting this answer. Running <code>strings level01</code> will print out a list of all ASCII strings in this program. Although this gave the answer went I first tried IO, the executable has since been patched to prevent this. Why do I mention this, then? Because it seems the IO admin forgot about <code>strings -el</code>, which allows <code>strings</code> to pull in longer strings... and which will give us the answer.</p>
				<p><code>gdb -q level01</code> will bring you into the debugger, at which point we can run <code>disassemble main</code> to see how the executable works.</p>
				<p>After the function prologue, we see <code>0x080485a6 &lt;main+16&gt;: cmp DWORD PTR [ebp+0x8],0x2</code>, which shows us that our <code>argc</code> must be equal to 2... or that we must provide the program with a single argument. You can see that (if we don't pass this test) <code>0x080485aa &lt;main+20&gt;: je 0x80485ca &lt;main+52&gt;</code> will eventually lead us to printing out the usage info (run the program without arguments to see this!) and exiting. Obviously not what we want.</p>
				<p>So, we know that we need a single argument. Continuing on with our trace, we follow the jump to <code>0x080485ca &lt;+52&gt;: call 0x804852d &lt;pass&gt;</code>. By running <code>disassemble pass</code>, we can see that this function call will take the address <code>ebp-0x4</code> and load some values into it... incidentally, converting the hex that is loaded at this point will give you your answer. But yet still we press on!</p>
				<p>Returning to the main function, we can follow the program flow to the <code>mbstowcs</code> function. A cursory reading of any C manual will show you that this function will convert its input to a wide string.</p>
				<p>Continuing through the program execution, we see that our input is compared with the password created in <code>pass</code> with <code>wcscmp</code>. The relevant lines are:</p>
				<p><code>0x08048605 &lt;main+111&gt;: jne  0x804860c  &lt;main+118&gt;</code></p>
				<p><code>0x08048607 &lt;main+113&gt;: call 0x80484b4  &lt;win&gt;</code></p> 
				<p><code>0x0804860c &lt;main+118&gt;: mov  DWORD PTR  [esp],0x8048795</code></p>
				<p><code>0x08048613 &lt;main+125&gt;: call 0x80483e8  &lt;puts@plt&gt;</code></p>
				<p>Oooh look, a <code>win</code> function! Looking at that will show us that the win function will give us a shell with an EUID of level2, which will win the level. It also proves that our input has to match the string created in <code>pass</code> for us to <code>call win</code>.</p>
				<p>To get our answer, we can remember the pass function and grab the hex there, or we can look at the argument used in the comparison. Both with get us the same string, but we'll be grabbing it at different points.</p>
				<p>To pull our answer from the comparison, we set <code>break *0x080485fe</code> (ie, stop program execution at the comparison). Then, by calling <code>run AAAA</code> (note that "A" is traditionally used in situations like this mostly because 0x41 0x41 0x41 0x41 [etc] is easily recognizable), we can see our program stop once both strings are loaded into memory.</p>
				<p><code>x/32xw 0x8049140</code> (see the comparison function) will let us see both variables in memory... notice the bunch of 41s near the bottom? The first bunch of bytes will be the actual password, terminated by 0x00, and will be our answer.</p>
				<p>Password (highlight to view): <span style='color:white;'>tLmf7msJTJHEpw</span</p>

				<h3>level2</h3>
				<p>Coming soon...</p>
			</div>
		</div>
	</content>
</body>
</html>
